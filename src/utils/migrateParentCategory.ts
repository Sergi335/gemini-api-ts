import dotenv from 'dotenv'
import { connect, disconnect } from 'mongoose'
import categoryModel from '../models/schemas/categorySchema'

// Cargar variables de entorno una sola vez
dotenv.config()

async function connectToDatabase (): Promise<void> {
  try {
    const dbUri = process.env.DB_URI_TEST
    if (typeof dbUri !== 'string' || dbUri.trim() === '') {
      throw new Error('DB_URI_TEST no est√° definido en las variables de entorno')
    }
    await connect(dbUri)
    console.log('üì¶ Conectado a MongoDB (TEST)')
  } catch (error) {
    console.error('‚ùå Error conectando a MongoDB:', error)
    throw error
  }
}

async function closeConnection (): Promise<void> {
  try {
    await disconnect()
    console.log('üîå Desconectado de MongoDB')
  } catch (error) {
    console.error('‚ùå Error desconectando de MongoDB:', error)
    throw error
  }
}

async function migrateParentCategoryToParentId (): Promise<void> {
  try {
    console.log('üöÄ Iniciando migraci√≥n de parentCategory a parentId...')

    // Conectar a la base de datos
    await connectToDatabase()
    console.log('‚úÖ Conectado a la base de datos')

    // Primero, vamos a ver una muestra de documentos para entender la estructura
    console.log('\nüîç Analizando estructura de datos...')
    const sampleCategories = await categoryModel.find({}).limit(5).lean()
    console.log('üìã Muestra de categor√≠as encontradas:')
    sampleCategories.forEach((cat, index) => {
      console.log(`  ${index + 1}. ID: ${String(cat._id)}`)
      console.log(`     Campos: ${Object.keys(cat).join(', ')}`)
      if ('parentCategory' in cat) {
        console.log(`     parentCategory: ${String((cat as any).parentCategory)}`)
      }
      if ('parentId' in cat) {
        console.log(`     parentId: ${String(cat.parentId ?? 'undefined')}`)
      }
      console.log('')
    })

    // Buscar todas las categor√≠as que tienen el campo parentCategory
    const categoriesWithParentCategory = await categoryModel.find({
      parentCategory: { $exists: true }
    }).lean()

    console.log(`üìä Encontradas ${categoriesWithParentCategory.length} categor√≠as con campo parentCategory`)

    // Tambi√©n buscar por otros posibles nombres de campo
    const alternativeFields = await categoryModel.find({
      $or: [
        { parent: { $exists: true } },
        { parentCategoryId: { $exists: true } },
        { parent_id: { $exists: true } }
      ]
    }).lean()

    if (alternativeFields.length > 0) {
      console.log(`üîç Encontradas ${alternativeFields.length} categor√≠as con campos padre alternativos:`)
      alternativeFields.forEach((cat, index) => {
        console.log(`  ${index + 1}. ID: ${String(cat._id)}`)
        const catAny = cat as any
        if (typeof catAny.parent === 'string') console.log(`     parent: ${String(catAny.parent)}`)
        if (typeof catAny.parentCategoryId === 'string') console.log(`     parentCategoryId: ${String(catAny.parentCategoryId)}`)
        if (typeof catAny.parent_id === 'string') console.log(`     parent_id: ${String(catAny.parent_id)}`)
      })
    }

    if (categoriesWithParentCategory.length === 0) {
      console.log('‚úÖ No hay categor√≠as que migrar con campo parentCategory')
      console.log('üí° Verifica que el campo se llame exactamente "parentCategory"')
      return
    }

    let migratedCount = 0
    let errorCount = 0
    let skippedCount = 0

    // Procesar cada categor√≠a
    for (const category of categoriesWithParentCategory) {
      try {
        const categoryAny = category as any
        console.log(`\nüîÑ Procesando categor√≠a ${String(category._id)}:`)
        console.log(`   parentCategory actual: ${String(categoryAny.parentCategory)}`)
        console.log(`   parentId actual: ${String(category.parentId ?? 'undefined')}`)

        const updateData: any = {}

        // Si existe parentCategory, copiarlo a parentId
        if (typeof categoryAny.parentCategory === 'string' && categoryAny.parentCategory.trim() !== '') {
          updateData.parentId = categoryAny.parentCategory
          console.log(`   ‚û°Ô∏è  Copiando "${String(categoryAny.parentCategory)}" a parentId`)
        } else {
          console.log('   ‚ö†Ô∏è  parentCategory est√° vac√≠o o no es string, saltando...')
          skippedCount++
          continue
        }

        // Actualizar el documento
        const updateResult = await categoryModel.updateOne(
          { _id: category._id },
          {
            $set: updateData,
            $unset: { parentCategory: 1 } // Eliminar el campo parentCategory
          }
        )

        console.log('   üìù Resultado de actualizaci√≥n:')
        console.log(`      Documentos coincidentes: ${updateResult.matchedCount}`)
        console.log(`      Documentos modificados: ${updateResult.modifiedCount}`)

        if (updateResult.modifiedCount > 0) {
          migratedCount++
          const parentValue = String(categoryAny.parentCategory ?? 'null')
          const categoryId = String(category._id)
          console.log(`   ‚úÖ Migrada categor√≠a ${categoryId}: parentCategory="${parentValue}" ‚Üí parentId="${parentValue}"`)
        } else {
          console.log(`   ‚ùå No se pudo modificar la categor√≠a ${String(category._id)}`)
          errorCount++
        }
      } catch (error) {
        errorCount++
        const categoryId = String(category._id)
        console.error(`   ‚ùå Error migrando categor√≠a ${categoryId}:`, error)
      }
    }

    console.log('\nüìà Resumen de migraci√≥n:')
    console.log(`‚úÖ Categor√≠as migradas exitosamente: ${migratedCount}`)
    console.log(`‚è≠Ô∏è  Categor√≠as saltadas (vac√≠as): ${skippedCount}`)
    console.log(`‚ùå Errores: ${errorCount}`)
    console.log(`üìä Total procesadas: ${categoriesWithParentCategory.length}`)

    // Verificar la migraci√≥n
    console.log('\nüîç Verificando migraci√≥n...')
    const remainingOldFields = await categoryModel.countDocuments({
      parentCategory: { $exists: true }
    })

    const newFieldsCount = await categoryModel.countDocuments({
      parentId: { $exists: true }
    })

    console.log(`üìä Categor√≠as con parentCategory restantes: ${remainingOldFields}`)
    console.log(`üìä Categor√≠as con parentId: ${newFieldsCount}`)

    if (remainingOldFields === 0 && migratedCount > 0) {
      console.log('üéâ ¬°Migraci√≥n completada exitosamente!')
    } else if (migratedCount === 0) {
      console.log('‚ö†Ô∏è  No se migr√≥ ninguna categor√≠a. Revisa los logs arriba.')
    } else {
      console.log('‚ö†Ô∏è  A√∫n quedan categor√≠as con el campo antiguo')
    }
  } catch (error) {
    console.error('üí• Error durante la migraci√≥n:', error)
    throw error
  } finally {
    // Cerrar conexi√≥n
    await closeConnection()
    console.log('üîå Conexi√≥n a la base de datos cerrada')
  }
}

// Funci√≥n para hacer rollback si es necesario
async function rollbackMigration (): Promise<void> {
  try {
    console.log('üîÑ Iniciando rollback de migraci√≥n...')

    await connectToDatabase()
    console.log('‚úÖ Conectado a la base de datos')

    // Buscar todas las categor√≠as que tienen parentId
    const categoriesWithParentId = await categoryModel.find({
      parentId: { $exists: true }
    }).lean()

    console.log(`üìä Encontradas ${categoriesWithParentId.length} categor√≠as con campo parentId`)

    let rolledBackCount = 0

    for (const category of categoriesWithParentId) {
      try {
        const updateData: any = {}

        if (typeof category.parentId === 'string' && category.parentId.trim() !== '') {
          updateData.parentCategory = category.parentId
        }

        await categoryModel.updateOne(
          { _id: category._id },
          {
            $set: updateData,
            $unset: { parentId: 1 }
          }
        )

        rolledBackCount++
        const parentValue = String(category.parentId ?? 'null')
        const categoryId = String(category._id)
        console.log(`‚úÖ Rollback categor√≠a ${categoryId}: parentId="${parentValue}" ‚Üí parentCategory="${parentValue}"`)
      } catch (error) {
        const categoryId = String(category._id)
        console.error(`‚ùå Error en rollback categor√≠a ${categoryId}:`, error)
      }
    }

    console.log(`üîÑ Rollback completado. Categor√≠as revertidas: ${rolledBackCount}`)
  } catch (error) {
    console.error('üí• Error durante el rollback:', error)
    throw error
  } finally {
    await closeConnection()
    console.log('üîå Conexi√≥n cerrada')
  }
}

// Funci√≥n para mostrar el estado actual de la base de datos
async function checkMigrationStatus (): Promise<void> {
  try {
    console.log('üîç Verificando estado actual de la base de datos...')

    await connectToDatabase()

    const totalCategories = await categoryModel.countDocuments()
    const withParentCategory = await categoryModel.countDocuments({
      parentCategory: { $exists: true }
    })
    const withParentId = await categoryModel.countDocuments({
      parentId: { $exists: true }
    })

    console.log('\nüìä Estado actual:')
    console.log(`üìã Total de categor√≠as: ${totalCategories}`)
    console.log(`üî∏ Con campo parentCategory: ${withParentCategory}`)
    console.log(`üîπ Con campo parentId: ${withParentId}`)

    if (withParentCategory > 0) {
      console.log('\n‚ö†Ô∏è  Se encontraron categor√≠as con el campo parentCategory antiguo')
      console.log('üí° Ejecuta la migraci√≥n con: npm run migrate-parent-category')
    } else if (withParentId > 0) {
      console.log('\n‚úÖ Todas las categor√≠as est√°n usando el campo parentId correcto')
    } else {
      console.log('\nüìù No se encontraron categor√≠as con campos padre')
    }
  } catch (error) {
    console.error('üí• Error verificando estado:', error)
    throw error
  } finally {
    await closeConnection()
  }
}

// Ejecutar migraci√≥n
async function main (): Promise<void> {
  const args = process.argv.slice(2)
  const isRollback = args.includes('--rollback')
  const isCheck = args.includes('--check')

  try {
    if (isCheck) {
      await checkMigrationStatus()
    } else if (isRollback) {
      await rollbackMigration()
    } else {
      await migrateParentCategoryToParentId()
    }
  } catch (error) {
    console.error('üí• Error en la ejecuci√≥n:', error)
    process.exit(1)
  }
}

// Solo ejecutar si es llamado directamente
if (require.main === module) {
  main().catch((error) => {
    console.error('üí• Error fatal:', error)
    process.exit(1)
  })
}

export { checkMigrationStatus, migrateParentCategoryToParentId, rollbackMigration }
